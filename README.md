# Тестовое задание
**Ожидемый результат**: прототип API интернет магазина с тремя функцианальными блоками (личный кабинет пользователя, каталог товаров, административный модуль ("админка")). 

## Реализация API
### Фреймворк Laravel
Т.к. мы разрабатываем апи для курпного интернет магазина с большим фнукционалом, то мы сталкнемс с такими задачами: 
- Грамотно реализолизовать большое кол-во эндпоинтов;
- Безопасное обращение к API;
- Большое кол-во запросов к API;

Плюсы Laravel:
- Laravel содержит в себе много выстроенных модулей для защиты от атак и кэширования данных, что позволит ускорить и облегчить разработку.
- Модульность приложений Laravel, позволит быстро расширять функционал.
- Встроенные алгоритмы кэширования так же уменьшат нагрузку на сервер.

____
### Работа с базами данных
Были использованя **MySQL** и **Redis** для кэширования значиний.
#### Сиситема использования:
- MySQL/PostgreSQL:
  - Хранить все основные данные, такие как:
    - Информация о товарах (название, описание, цена, характеристики...)
    - Информация о пользователях (имя, email, адрес, телефон...)
    - Информация о заказах (товары, цены, статус, адрес доставки...)
- Redis:
  - Кэширование запрашиваемых данных:
    - При первичном запросе, данные, получаеые из SQL бд, кэшируются
    - При измении данных, запись удаляется из Redis и будет добалена при следующем запросе

## Пример реализации кэширования (Route::get - 'goods/{good_id}/{regin_id}')
```php
public function get($good_id, $region_id){
        $cacheKey = "product_price_{$good_id}_{$region_id}";
        $data = Cache::remember($cacheKey, 60*60*60, function() use ($good_id, $region_id){
            $product = Good::find($good_id);
            if (! $product) {
                return response()->json(['error' => 'Product not found'], 404);
            }

            $productName = $product->name;

            $price = Price::where(['good_id' => $good_id, 'region_id'=>$region_id])->first();
            if (! $price) {
                return response()->json(['error' => 'Price not found for this region'], 404);
            }

            $regionPrice = $price->value;

            $regionName = Region::find($region_id);

            return [
                'product_name' => $productName,
                'region_price' => $regionPrice,
                'region_name' =>$regionName->name,
                'product_quantity' => $product->quantity,

            ];

        });

        return response()->json($data);

    }
```
#### MySQL
- Хорошо подходит для хранения структурированных данных, таких как информация о товарах, пользователях, заказах и т.д
  ![db](https://github.com/ddos-pmv/portfolio/blob/main/vk_test.png?raw=true)
#### Redis
- Обеспечивает высокую производительность и низкую задержку
- Легко масштабируется
____ 
## Схема обработки заказа
![](https://github.com/ddos-pmv/portfolio/blob/main/Sheme.png?raw=true)
____
## [Прототип API по оформлению заказа](./backend/orderPrototype/proto.php)
____
## Система хранения медиа контента
Для хранения медиаконтента наилучшим выбором будет использование **облачных хранилищ**.
Из плюсов можно отметить:
 - Уже реализованная защита данных.
 - Гарантия сохранности данных.
 - Производительность.

Минусом является зависимость от сторнних сервисов.
____
## Установка
1. Запустите базы дынных. Дамп sql лежит по пути vk_test/db/dump.sql
2. Скопируйте репозиторий.
```
git clone https://github.com/ddos-pmv/vk_tes
cd vk_test/backend
```
3. Скопируйте и настройте файл окружения.
4. Запуск на локальном сервере
```
php artisan serve
```

### Работа с api
#### *Step 1. Создание пользователя.*
![](https://github.com/ddos-pmv/portfolio/blob/main/Reg.png?raw=true)

#### *Step 2.Получение bearer токена.*
![](https://github.com/ddos-pmv/portfolio/blob/main/Bearer.png?raw=true)

#### *Step 3. Пробуем эндпоинты.*
Все не закоментированные [routes](./backend/routes/api.php) должны работают.

____



## Рекомендации по доработке
- *JWT авторизация*. Сейчас используется Bearer Token, выбор обусловлен тем, что я просто не успевал доделать нормальную авторизацию. Авторизация с помощью JWT токена безопаснне Bearer!
- *pgSQL*. Постгре работает немного быстрее mySQL
